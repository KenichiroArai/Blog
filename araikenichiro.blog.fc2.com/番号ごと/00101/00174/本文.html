<h2>本記事の元になるXのポスト</h2>

<p>下記のXのポストを整理して、本記事にまとめた。</p>

<blockquote class="twitter-tweet">
  <p lang="ja" dir="ltr">Claude codeにガチギレしつつ、こまめなコミットの大事さに気づいた件 <a href="https://t.co/7UsLhgQmLB">https://t.co/7UsLhgQmLB</a><br><br>コミットやブランチ戦略は当然として優秀なIDEなら全部記憶しているので戻せる。VSCodeは微妙かな。使いづらいしプラグイン必須？Eclipseならファイルが消えても戻せる。保存ごとに全部記憶している</p>
  &mdash; 新井健一朗@want to (@arai_kenichiro) <a href="https://twitter.com/arai_kenichiro/status/1955099711683301601?ref_src=twsrc%5Etfw">August 12, 2025</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>元になるのはXのポストで、思いつきながら書いているため、全体的にまとまりがないのでメモ代わりとして見て欲しい。</p>

<p>動画の内容は、コミットするタイミングをある程度のまとまりで行っていたため、その間に生成AIのコード修正でそれまでの修正が上書きされてしまったため、こまめにコミットしたほうが良いという話である。</p>

<h2>結論</h2>

<p>AIコーディング時代において、こまめなコミットは重要であるが、コミット履歴だけで全てを管理しようとするのは現実的ではない。特に複数人での開発や大規模プロジェクトでは、<strong>GitHubのIssueやProject（RedmineやJiraなど）を活用し、そこでまとめるのが定石である</strong>。</p>

<p>こまめなコミットは開発の安全性を高める手段であり、詳細な管理は適切なプロジェクト管理ツールに委ねることで、効率的で持続可能な開発が可能になる。</p>

<h2>こまめなコミットの実践</h2>

<h3>基本的な考え方</h3>

<p>私の仕事のほとんどはSVNであるが、それでもこまめにコミットしていた。開発中は開発用ブランチのみであるが、こまめにコミットするということは、どのように修正するかを意識しているということである。コミットする際は、ビルドエラーが発生していないこと、共通部分の動作が可能であることが最低限のルールである。</p>

<p>自分が開発している部分（画面など）の動作が可能であれば十分である。どうしても一度確定したい場合は、動作しなくてもコミットすることがあるが、基本的には動作する状態でコミットしている。これは修正範囲が限定されているということでもあり、コミット範囲も少ないため、効率よく実装できる。</p>

<h3>開発環境の工夫</h3>

<p>さらに私の場合は、メモリが潤沢な開発機の場合、自分の開発用と検証用を2つ用意していたこともあった。検証用は開発用でコミットした際にすぐに更新してエラーがないことを確認し、先に更新をかけてビルドエラーが発生していないことを確認する。</p>

<p>自分が開発用でコミットした際に、なぜ検証用で更新をかけて確認するかというと、ローカルが壊れている場合があるからである。開発用ではビルドエラーが発生していない場合があるため、念のために検証用で確認する。開発の段階からCIされていればそこで確認できるが、CI環境を用意していない現場もあるからである。</p>

<h2>IDEの履歴機能について</h2>

<h3>優秀なIDEの特徴</h3>

<p>コミットやブランチ戦略は当然として、優秀なIDEであれば全ての変更履歴を記憶しているため、いつでも戻すことが可能である。VSCodeは微妙なところであり、使いづらく、プラグインが必須となる。一方、Eclipseであればファイルが消えても戻すことができ、保存ごとに全て記憶している。</p>

<h3>Eclipseの履歴機能</h3>

<p>Eclipseに関することは下記のXでポストしている。</p>

<blockquote class="twitter-tweet">
  <p lang="ja" dir="ltr">Eclipseの履歴機能は優れているが、その中に「ローカル・ヒストリーの前回のものと置換」があるけど、これが結構便利。直前に保存したものを元に戻してくれる。 <a href="https://t.co/6kwQM64qtw">pic.twitter.com/6kwQM64qtw</a></p>
  &mdash; 新井健一朗@want to (@arai_kenichiro) <a href="https://twitter.com/arai_kenichiro/status/1897920954644545631?ref_src=twsrc%5Etfw">March 7, 2025</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2>コミット・ブランチ戦略</h2>

<h3>AIコーディング時代のブランチ戦略</h3>

<p>下記の通り、コミット・ブランチ戦略については、現在はこれくらい細かくても問題ないと考えている。</p>

<p>
  <a href="https://blog-imgs-163.fc2.com/a/r/a/araikenichiro/00174_001.png" target="_blank">
    <img src="https://blog-imgs-163.fc2.com/a/r/a/araikenichiro/00174_001.png" alt="00174_001.png" width="600" border="0">
  </a>
</p>

<p>図にすると上記のようなイメージである。issueブランチやAI作業単位ブランチは、もっと細かくても良いかもしれない。ただし、マージごとに削除するという方針である。また、issueブランチ以降はどこまでをリモートブランチにするかについては、マージごとにすぐに削除するのであれば、どちらでも構わないと考えている。</p>

<h3>ブランチ戦略の補足</h3>

<p>ブランチ戦略に該当するが、main、developなどに対するマージやGitHubなどのプルリクエストがタグ代わりのタイミングとなる。developや一区切りとなるfeatureなどのブランチを用意しておけば、区切りが見えやすく、一定の範囲で元に戻すことがしやすくなる。</p>

<h2>タグとコミット履歴の活用</h2>

<h3>タグの活用方法</h3>

<p>目印としてはバージョン（リリース）だけではなく、タグがあるため、そのタグを有効活用する方法もある。タグも作っては消しても問題ないため、あまりコミット履歴から状況を把握するのは、リリースしてからでも難しいのが現状である。コミットをまとめるというやり方もあるが、基本的にコミット履歴はログとして考えた方が良い。</p>

<h3>コミット履歴の考え方</h3>

<p>コミット単位やコメント管理ばかりに目が行くと本末転倒になる。特に複数人や規模が大きくなると現実的ではないと考えている。コストをかければできるが、GitHubのIssueやProject（RedmineやJiraなど）を活用し、そこでまとめるのが定石である。</p>

<h2>リンク</h2>

<ol>
  <li>
    <a href="https://github.com/KenichiroArai/Blog/tree/main/araikenichiro.blog.fc2.com/%E7%95%AA%E5%8F%B7%E3%81%94%E3%81%A8/00101/00174" target="_blank">本記事のGitHubでの管理</a>
  </li>
  <li>
    <a href="https://x.com/arai_kenichiro/status/1955099711683301601" target="_blank">Xの元になったポスト</a>
  </li>
</ol>
