<h2>
  本記事の元となったXのポスト
</h2>

<p>
  本記事の元は以下のXのポストである。思いつくままに記述しているため、メモ代わりとして参照されたい。
</p>

<blockquote class="twitter-tweet">
  <p lang="ja" dir="ltr">Claude codeにガチギレしつつ、こまめなコミットの大事さに気づいた件 <a href="https://t.co/7UsLhgQmLB">https://t.co/7UsLhgQmLB</a><br><br>コミットやブランチ戦略は当然として優秀なIDEなら全部記憶しているので戻せる。VSCodeは微妙かな。使いづらいしプラグイン必須？Eclipseならファイルが消えても戻せる。保存ごとに全部記憶している</p>
  &mdash; 新井健一朗@want to (@arai_kenichiro) <a href="https://twitter.com/arai_kenichiro/status/1955099711683301601?ref_src=twsrc%5Etfw">August 12, 2025</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>
  動画の内容は、コミットのタイミングをある程度まとまりごとに行っていたため、その間に生成AIによるコード修正でファイルが消されてしまった。したがって、こまめにコミットしたほうが良いという話である。
</p>

<h2>
  結論
</h2>

<p>
  AIコーディング時代において、こまめなコミットは重要だ。しかし、コミット履歴だけですべてを管理しようとするのは現実的ではない。特に複数人での開発や大規模プロジェクトでは、<strong>GitHubのIssueやProject（RedmineやJiraなど）を活用し、そこでまとめるのが定石だ</strong>。
</p>

<p>
  こまめなコミットは開発の安全性を高める手段であり、詳細な管理は適切なプロジェクト管理ツールに委ねることで、効率的で持続可能な開発が実現できる。
</p>

<h2>
  こまめなコミットの実践
</h2>

<h3>
  基本的な考え方
</h3>

<p>
  自分の業務のほとんどはSVNであるが、それでもこまめにコミットしている。開発中は開発用ブランチのみを使うが、こまめにコミットするということは、どのように修正するかを常に意識しているということだ。コミット時には、ビルドエラーが発生していないこと、共通部分の動作が可能であることを最低限のルールとしている。自分が担当している部分（画面など）は、基本的に、自分しか使っていはずなので、動作しなくても十分なことは多い。
</p>

<h3>
  開発環境の工夫
</h3>

<p>
  さらに、自分の場合はメモリに余裕のある開発機であれば、開発用と検証用の2つの環境を用意することもあった。検証用は、開発用でコミットした直後に更新し、エラーがないことを確認するためのものだ。また、先に更新をかけてビルドエラーが発生していないかも確認する。ビルドエラーがある場合は、コミット履歴を確認して、修正者に知らせ、開発用はまだ更新しない。
</p>

<p>
  開発用でコミットした際に、なぜ検証用で更新して確認するかというと、ローカル環境が壊れている場合があるからだ。開発用ではビルドエラーが発生していなくても、念のため検証用で確認する。開発段階からCIが導入されていればそこで確認できるが、CI環境が用意されていない現場も存在する。
</p>

<h2>IDEの履歴機能について</h2>

<h3>優秀なIDEの特徴</h3>

<p>
  コミットやブランチ戦略は当然として、優秀なIDEであれば全ての変更履歴を記憶しているため、いつでも元に戻すことができる。VSCodeは正直なところ微妙であり、使い勝手が悪く、プラグインの導入が必須となる。一方、Eclipseであればファイルが消えても復元でき、保存のたびに全ての履歴を記録している。
</p>

<h3>
  Eclipseの履歴機能
</h3>

<p>
  Eclipseの履歴機能については、下記のXでポストしている。
</p>

<blockquote class="twitter-tweet">
  <p lang="ja" dir="ltr">Eclipseの履歴機能は優れているが、その中に「ローカル・ヒストリーの前回のものと置換」があるけど、これが結構便利。直前に保存したものを元に戻してくれる。 <a href="https://t.co/6kwQM64qtw">pic.twitter.com/6kwQM64qtw</a></p>
  &mdash; 新井健一朗@want to (@arai_kenichiro) <a href="https://twitter.com/arai_kenichiro/status/1897920954644545631?ref_src=twsrc%5Etfw">March 7, 2025</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2>
  コミット・ブランチ戦略
</h2>

<h3>
  AIコーディング時代のブランチ戦略
</h3>

<p>
  下記の通り、コミット・ブランチ戦略については、現在はこれほど細かくしても問題ないと考える。
</p>

<p>
  <a href="https://blog-imgs-163.fc2.com/a/r/a/araikenichiro/00174_001.png" target="_blank">
    <img src="https://blog-imgs-163.fc2.com/a/r/a/araikenichiro/00174_001.png" alt="00174_001.png" width="600" border="0">
  </a>
</p>

<p>
  図にすると上記のようなイメージとなる。issueブランチやAI作業単位ブランチは、さらに細かくしてもよい。ただし、マージごとに削除する方針である。また、issueブランチ以降をどこまでリモートブランチとするかについては、マージごとにすぐ削除するのであれば、どちらでも構わない。
</p>

<h3>
  ブランチ戦略
</h3>

<p>
  mainやdevelopなどへのマージ、あるいはGitHubでのプルリクエストがタグの代わりとなるタイミングである。developや一区切りとなるfeatureブランチを用意しておけば、区切りが明確になり、そのマージ時のIDやプルリクエストのIDが目印となるため、一定範囲で元に戻すことも容易である。
</p>

<h2>
  リンク
</h2>

<ol>
  <li>
    <a href="https://github.com/KenichiroArai/Blog/tree/main/araikenichiro.blog.fc2.com/%E7%95%AA%E5%8F%B7%E3%81%94%E3%81%A8/00101/00174" target="_blank">本記事のGitHubでの管理</a>
  </li>
  <li>
    <a href="https://x.com/arai_kenichiro/status/1955099711683301601" target="_blank">Xの元になったポスト</a>
  </li>
</ol>
